
using MemoryReads64;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

public class CheckpointLookup
{
    static Dictionary<byte[], byte[]> checkpointSwapTable = new Dictionary<byte[], byte[]>(new ByteArrayComparer());

    public static void initialiseSwapTable()
    {
        if (checkpointSwapTable.Keys.Count == 0)
        {
            // Prologue
            checkpointSwapTable.Add(new byte[] { 0x4C, 0x4E, 0x96, 0x58, 0xBB, 0xB4, 0x30, 0x78, 0x46, 0x49, 0x54, 0x5A, 0x31, 0x35, 0x32, 0x36 }
           , new byte[] { 0x8F, 0x60, 0x1E, 0x58, 0x19, 0x36, 0x4E, 0x8D, 0x46, 0x49, 0x54, 0x5A, 0x31, 0x35, 0x32, 0x36 }); // picking up codex skip
            checkpointSwapTable.Add(new byte[] { 0x8F, 0x60, 0x1E, 0x58, 0x19, 0x36, 0x4E, 0x8D, 0x46, 0x49, 0x54, 0x5A, 0x31, 0x35, 0x32, 0x36 }
           , new byte[] { 0x4A, 0xE0, 0x6D, 0x58, 0x74, 0x70, 0xAC, 0xAC, 0x46, 0x49, 0x54, 0x5A, 0x31, 0x35, 0x32, 0x36 }); // Rappel to slide
            checkpointSwapTable.Add(new byte[] { 0x4A, 0xE0, 0x6D, 0x58, 0x74, 0x70, 0xAC, 0xAC, 0x46, 0x49, 0x54, 0x5A, 0x31, 0x35, 0x32, 0x36 }
            , new byte[] { 0xE2, 0xDB, 0x52, 0x33, 0xAD, 0x66, 0xFD, 0xA6, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // End cutscene in Prologue
            
            // Ch1
            checkpointSwapTable.Add(new byte[] { 0xE2, 0xDB, 0x52, 0x33, 0xAD, 0x66, 0xFD, 0xA6, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0x6B, 0x40, 0x25, 0x33, 0x84, 0x6D, 0xBC, 0x36, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // first cutscene in appartment
            checkpointSwapTable.Add(new byte[] { 0x6B, 0x40, 0x25, 0x33, 0x84, 0x6D, 0xBC, 0x36, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0x02, 0xBC, 0xDE, 0x33, 0xF4, 0x12, 0x30, 0x17, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // car cutscene
            checkpointSwapTable.Add(new byte[] { 0x8B, 0xC3, 0x2D, 0x33, 0x0D, 0xC7, 0x02, 0x97, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0x03, 0x1B, 0xCB, 0x33, 0x39, 0x75, 0xD9, 0xE0, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // meet danik


            // Ch2
            checkpointSwapTable.Add(new byte[] { 0x74, 0xE7, 0x23, 0x33, 0x60, 0x49, 0x6F, 0xAF, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0x11, 0x75, 0x90, 0x33, 0x9C, 0x62, 0x27, 0xE3, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // wake up
            checkpointSwapTable.Add(new byte[] { 0x11, 0x75, 0x90, 0x33, 0x9C, 0x62, 0x27, 0xE3, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0xFF, 0x67, 0xB0, 0x33, 0x99, 0xED, 0xD7, 0xAE, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // Bridge
            checkpointSwapTable.Add(new byte[] { 0xFF, 0x67, 0xB0, 0x33, 0x99, 0xED, 0xD7, 0xAE, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
            , new byte[] { 0xFB, 0x6E, 0x9C, 0x33, 0x85, 0x6E, 0xC7, 0x88, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // where can i find an eva suit
            checkpointSwapTable.Add(new byte[] { 0x75, 0x46, 0x10, 0x33, 0x2D, 0xAC, 0x04, 0xE9, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }
           , new byte[] { 0x75, 0x46, 0x10, 0x33, 0xD7, 0x98, 0xCF, 0x13, 0x50, 0x52, 0x49, 0x43, 0x45, 0x32, 0x30, 0x36 }); // Jump section cutscene

            // Ch3
            checkpointSwapTable.Add(new byte[] { 0x27, 0xB7, 0xC8, 0x4F, 0x67, 0x60, 0xC0, 0xA1, 0x4D, 0x41, 0x52, 0x49, 0x4E, 0x45, 0x4C, 0x4C }
            , new byte[] { 0x20, 0x90, 0x9F, 0x4F, 0x99, 0xCE, 0xC2, 0xF2, 0x4D, 0x41, 0x52, 0x49, 0x4E, 0x45, 0x4C, 0x4C }); // Meet Ellie
        }
    }

    public static bool swapCheckPointIfInTable(Process Proc, Pointer pointerInstance, byte[] currentCheckpoint)
    {
        if(checkpointSwapTable.TryGetValue(currentCheckpoint, out byte[] value))
        {
            Trainer.WritePointerByteArray(Proc, pointerInstance, value);
            return true;
        }

        return false;
    }

}

public class ByteArrayComparer : IEqualityComparer<byte[]>
{
    public bool Equals(byte[] left, byte[] right)
    {
        if (left == null || right == null)
        {
            return left == right;
        }
        return left.SequenceEqual(right);
    }
    public int GetHashCode(byte[] key)
    {
        if (key == null)
            throw new ArgumentNullException("key");
        return key.Sum(b => b);
    }
}